#include "imports/stdlib.fc";
#include "./op-codes.fc";
#include "./messages.fc";
#include "./swap_utils.fc";
;;
;; Common
;;

const int msg_flag::bounceable = 0x18;

builder store_zeros(builder b, int n) asm "STZEROES";

slice addr_none() asm "b{00} PUSHSLICE";

;;
;; DEX
;;

const int ton_vault::swap = 0xea06185d;
const int min_tons_for_storage = 10000000; ;; 0.01 ton

(slice, int, cell, slice, cell) load_data() inline {
    slice ds = get_data().begin_parse();

    slice owner_address = ds~load_msg_addr();
    int noReferredUsers = ds~load_uint(32);
    cell referrer_data = ds~load_ref();
    slice root_addr = ds~load_msg_addr();
    cell swap_wallet_code = ds~load_ref();

    return (
        owner_address,
        noReferredUsers,
        referrer_data,
        root_addr,
        swap_wallet_code
    );
}


() save_data(
    slice owner_address,
    int noReferredUsers, 
    cell referrer_data, 
    slice root_addr, 
    cell swap_wallet_code
) impure inline {

}


() refer(int referral_reward, slice referral_addr) impure {
    var (
        slice owner_address,
        int noReferredUsers, 
        cell referrer_data, 
        slice root_addr, 
        cell swap_wallet_code
    ) = load_data();

    ;; slice referral_addr = swap_data~load_ref().begin_parse();
    slice ref_data = referrer_data.begin_parse();
    
    if(referral_addr.slice_empty?() == 0 & ref_data.slice_empty?()){
        slice addr = referral_addr~load_msg_addr();
        ref_data.end_parse();
        referrer_data = begin_cell().store_slice(addr).end_cell();
        var msg_body = begin_cell()
                .store_uint(op::update_referral, 32)
                .store_slice(addr)
                .store_slice(owner_address)
            .end_cell();
        send_message_nobounce(referral_reward,calculate_user_swap_wallet_address(addr,root_addr,swap_wallet_code),msg_body,PAID_EXTERNALLY);
    }

    if(ref_data.slice_empty?() == 0){
        slice referrer_address = ref_data~load_msg_addr();
        ref_data.end_parse();
        var msg_body = begin_cell().end_cell();
        send_message_nobounce(referral_reward,calculate_user_swap_wallet_address(referrer_address,root_addr,swap_wallet_code),msg_body,PAID_EXTERNALLY);
    }
}

(int, int, int) calc_fees(int fixed_fee, int msg_value) inline_ref {
    int fee = msg_value * 1 / 100;
    int trade_fee = fee > fixed_fee ? fee : fixed_fee;
    int referral_reward = trade_fee * 18 / 100; 
    int trade_value = msg_value;

    return (trade_fee, referral_reward, trade_value);
}

() ton_to_jetton(int my_balance, slice in_msg_body, int msg_value) impure {
    var (
        slice owner_address,
        int noReferredUsers, 
        cell referrer_data, 
        slice root_addr, 
        cell swap_wallet_code
    ) = load_data();
    
    int fixed_fee = in_msg_body~load_coins();
    int GAS_FEE = in_msg_body~load_coins();
    int FWD_AMOUNT = in_msg_body~load_coins();
    int MIN_VALUE = in_msg_body~load_coins();
    slice swap_data = in_msg_body~load_ref().begin_parse();

    slice receipient_addr = swap_data~load_msg_addr();
    slice pool_addr = swap_data~load_msg_addr();
    slice ton_vault_addr = swap_data~load_msg_addr();
    int limit = swap_data~load_coins();
    int deadline = swap_data~load_uint(32);
    slice referral_addr = swap_data~load_ref().begin_parse();

    var (int trade_fee, int referral_reward, int trade_value) = calc_fees(fixed_fee, msg_value);

    if(trade_fee == fixed_fee){
        throw_unless(99, msg_value > GAS_FEE + fixed_fee);
    } else {
        throw_unless(100, msg_value > GAS_FEE);
    }

    refer(referral_reward, referral_addr);
    send_empty_message(trade_fee - referral_reward,root_addr,PAID_EXTERNALLY);

    cell msg_body = begin_cell()
        .store_uint(ton_vault::swap, 32)
        .store_uint(0, 64) ;; query_id:int64
        .store_coins(trade_value -  GAS_FEE - trade_fee) ;; amount:Coins # subtract gas
        ;; _:SwapStep
        .store_slice(pool_addr) ;; pool_addr:MsgAddressInt
        .store_uint(0, 1) ;; kind:SwapKind
        .store_coins(limit) ;; limit:Coins
        .store_maybe_ref(null()) ;; next:(Maybe ^SwapStep)
        ;; swap_params:^SwapParams
        .store_ref(
            begin_cell()
                .store_uint(now() + 60 * deadline, 32) ;; deadline:Timestamp # 5 min
                .store_slice(receipient_addr) ;; recipient_addr:MsgAddressInt
                .store_slice(addr_none()) ;; referral_addr:MsgAddress
                .store_maybe_ref(null()) ;; fulfill_payload:(Maybe ^Cell)
                .store_maybe_ref(null()) ;; reject_payload:(Maybe ^Cell)
                .end_cell()
        )
        .end_cell();

    send_raw_message(
        begin_cell()
            .store_uint(msg_flag::bounceable, 6)
            .store_slice(ton_vault_addr)
            .store_coins(trade_value - trade_fee)
            .store_zeros(1 + 4 + 4 + 64 + 32 + 1)
            .store_maybe_ref(msg_body)
            .end_cell(),
        0
    );
}


() jetton_to_jetton(int my_balance, slice in_msg_body, slice msg_sender, int msg_value) impure {
    var (
        slice owner_address,
        int noReferredUsers, 
        cell referrer_data, 
        slice root_addr, 
        cell swap_wallet_code
    ) = load_data();
    int fixed_fee = in_msg_body~load_coins();
    int GAS_FEE = in_msg_body~load_coins();
    int FWD_AMOUNT = in_msg_body~load_coins();
    int MIN_VALUE = in_msg_body~load_coins();
    slice swap_data = in_msg_body~load_ref().begin_parse();

    int query_id = swap_data~load_uint(64); ;; query_id
    int jetton_amount = swap_data~load_coins();
    slice from_address = swap_data~load_msg_addr();
    slice forward_payload = swap_data~load_ref().begin_parse();
    cell swap_payload = forward_payload~load_ref();
    slice aggregator_jetton_addr = forward_payload~load_msg_addr();
    slice jetton_vault = forward_payload~load_msg_addr();
    slice referral_addr = forward_payload~load_ref().begin_parse();
    var (int trade_fee, int referral_reward, int trade_value) = calc_fees(fixed_fee, msg_value);
    throw_unless(200, msg_value > FWD_AMOUNT + MIN_VALUE);

    refer(referral_reward, referral_addr);
    send_empty_message(trade_fee - referral_reward,root_addr,PAID_EXTERNALLY);

    var msg_body = begin_cell()
        .store_uint(op::transfer, 32)
        .store_uint(0, 64) ;; query_id
        .store_coins(jetton_amount)
        .store_slice(jetton_vault) ;; destination
        .store_slice(from_address) ;; response address
        .store_maybe_ref(begin_cell().end_cell())
        .store_coins(FWD_AMOUNT) ;; 0.25
        .store_maybe_ref(swap_payload)
    .end_cell();

    send_simple_message(MIN_VALUE,aggregator_jetton_addr,msg_body,PAID_EXTERNALLY);
}


() withdraw_excess_tokens(int my_balance, slice in_msg_body, slice msg_sender) impure {
    var (
        slice owner_address,
        int noReferredUsers, 
        cell referrer_data, 
        slice root_addr, 
        cell swap_wallet_code
    ) = load_data();

    throw_unless(250, my_balance > 1000000000);
    int withdrawal_amount = in_msg_body~load_coins();

    throw_unless(505, equal_slices(msg_sender, owner_address));
    throw_unless(506, my_balance > withdrawal_amount);

    int allowed_amount = min(withdrawal_amount, my_balance - min_tons_for_storage);

    send_empty_message(allowed_amount, owner_address, PAID_EXTERNALLY);
}


() retrieve_fee(int my_balance, slice in_msg_body, slice msg_sender, int msg_value, int operation) impure {

    var (
        slice owner_address,
        int noReferredUsers, 
        cell referrer_data, 
        slice root_addr, 
        cell swap_wallet_code
    ) = load_data();

    var msg_body = begin_cell().end_cell();

    if(operation == 1){
        slice receipient_addr = in_msg_body~load_msg_addr();
        slice pool_addr = in_msg_body~load_msg_addr();
        slice ton_vault_addr = in_msg_body~load_msg_addr();
        int limit = in_msg_body~load_coins();
        int deadline = in_msg_body~load_uint(32);
        cell referral_addr = in_msg_body~load_ref();
        
        msg_body = begin_cell()
            .store_uint(op::retrieve_fee, 32)
            .store_slice(owner_address)
            .store_uint(operation, 32)
            .store_ref(
                begin_cell()
                    .store_slice(receipient_addr)
                    .store_slice(pool_addr)
                    .store_slice(ton_vault_addr)
                    .store_coins(limit)
                    .store_uint(deadline, 32)
                    .store_ref(referral_addr)
                .end_cell()
            )
            .end_cell();
    } 


    if(operation == 2) {
        int query_id = in_msg_body~load_uint(64); ;; query_id
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        cell forward_payload = in_msg_body~load_ref();
        msg_body = begin_cell()
            .store_uint(op::retrieve_fee, 32)
            .store_slice(owner_address)
            .store_uint(operation, 32)
            .store_ref(
                begin_cell()
                    .store_uint(query_id, 64)
                    .store_coins(jetton_amount)
                    .store_slice(from_address)
                    .store_ref(forward_payload)
                .end_cell()
            )
        .end_cell();
    }
    

    send_simple_message(0,root_addr,msg_body,CARRY_REMAINING_GAS);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if(in_msg_body.slice_empty?()){
        return();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        ;; NOTE: Ignore bounced messages.
        return ();
    }
    slice msg_sender = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);

    var (
        slice owner_address,
        int noReferredUsers, 
        cell referrer_data, 
        slice root_addr, 
        cell swap_wallet_code
    ) = load_data();


    ;; if(op == op::swap_ton_to_jetton){
    ;;     ton_to_jetton(my_balance,in_msg_body,msg_value);
    ;; }

    ;; jettons to jetton 
    ;; jettons to ton
    if(op == op::transfer_notification) {
        ;; swap jetton to either ton or jetton
        int query_id = in_msg_body~load_uint(64); ;; query_id
        int jetton_amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        cell forward_payload = in_msg_body~load_ref();
        slice fws = forward_payload.begin_parse();
        cell swap_payload = fws~load_ref();
        slice aggregator_jetton_addr = fws~load_msg_addr();
        fws.end_parse();
        throw_unless(101, equal_slices(msg_sender, aggregator_jetton_addr));
        var new_msg_body = begin_cell()
            .store_uint(query_id, 64)
            .store_coins(jetton_amount)
            .store_slice(from_address)
            .store_ref(forward_payload)
        .end_cell().begin_parse();
        int operation = 2;
        retrieve_fee(my_balance,new_msg_body,msg_sender, msg_value, operation);
        ;; jetton_to_jetton_or_ton(my_balance,in_msg_body, msg_sender, msg_value);
    }

    if(op == op::make_swap_ton){
        int operation = 1;
        retrieve_fee(my_balance,in_msg_body, msg_sender, msg_value, operation); ;; get swap fee first
    }

    if(op == op::retrieved_fee) {
        throw_unless(105, equal_slices(msg_sender, root_addr));
        int operation = in_msg_body~load_uint(32);
        if(operation == 1){
            ton_to_jetton(my_balance,in_msg_body,msg_value);
        } 
        if(operation == 2){
            jetton_to_jetton(my_balance,in_msg_body, msg_sender, msg_value);
        }
       
    }

    if(op == op::update_referral) {
        var (
            slice owner_address,
            int noReferredUsers, 
            cell referrer_data, 
            slice root_addr, 
            cell swap_wallet_code
        ) = load_data();
        slice from_addr = in_msg_body~load_msg_addr();
        slice referrer = in_msg_body~load_msg_addr();
        throw_unless(106, equal_slices(calculate_user_swap_wallet_address(from_addr,root_addr,swap_wallet_code), msg_sender));
        throw_unless(107, equal_slices(referrer, owner_address));
        noReferredUsers += 1;
        save_data(owner_address,noReferredUsers,referrer_data,root_addr,swap_wallet_code);
    }

    if(op == op::withdraw_ton) {
        withdraw_excess_tokens(my_balance,in_msg_body,msg_sender);
    }

}


(slice, int, cell, slice, cell) get_swap_wallet_data() method_id {
    return load_data();
}